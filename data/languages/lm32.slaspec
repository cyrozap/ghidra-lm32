# sleigh specification file for LM32

define endian=big;
define alignment=4;

define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

# General Purpose Registers
define register offset=0x1000 size=4 [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25
	gp fp sp ra ea ba
];

# Control and Status Registers
define register offset=0x2000 size=4 [
	PC IE IM IP ICC DCC CC CFG EBA CFG2
];

# Debug Control and Status Registers
define register offset=0x3000 size=4 [
	DC DEBA JTX JRX BP0 BP1 BP2 BP3 WP0 WP1 WP2 WP3
];

define register offset=0x4000 size=4 contextreg;
define context contextreg
	LRset = (1,1) noflow  # 1 if the instruction before was a mov lr,pc
;

#
# Tokens
#

define token opfields(32)
	op = (26, 31)
	reg0 = (21, 25)
	reg1 = (16, 20)
	reg2 = (11, 15)
	imm16 = (0, 15)
	simm16 = (0, 15) signed
	imm26 = (0, 25)
	simm26 = (0, 25) signed
	imm5 = (0, 4)
	simm5 = (0, 4) signed
;

attach variables [ reg0 reg1 reg2 ] [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25
	gp fp sp ra ea ba
];

Rel16: reloc is simm16 [ reloc=inst_start+4*simm16; ] {
	export *:4 reloc;
}

Rel26: reloc is simm26 [ reloc=inst_start+4*simm26; ] {
	export *:4 reloc;
}

gpr0: reg0 is reg0 { export reg0; }
gpr0: "0" is reg0=0 { export 0:4; } # Special case

gpr1: reg1 is reg1 { export reg1; }
gpr1: "0" is reg1=0 { export 0:4; } # Special case

gpr2: reg2 is reg2 { export reg2; }
gpr2: "0" is reg2=0 { export 0:4; } # Special case


#
# Instructions
#

:srui reg0, reg1, imm5 is op=0x00 & reg0 & reg1 & imm5 {
	reg0 = reg1 >> imm5;
}

:nori reg0, reg1, imm16 is op=0x01 & reg0 & reg1 & imm16 {
	reg0 = ~(reg1 | imm16);
}

:muli reg0, reg1, simm16 is op=0x02 & reg0 & reg1 & simm16 {
	reg0 = ((reg1 * simm16) & 0xFFFFFFFF);
}

:sh reg0, reg1, simm16 is op=0x03 & reg0 & reg1 & simm16 {
	local address = reg1 + simm16;
	*[ram]:2 address = reg0;
}

:lb reg0, reg1, simm16 is op=0x04 & reg0 & reg1 & simm16 {
	local address = reg1 + simm16;
	reg0 = sext(*[ram]:1 address);
}

:sri reg0, reg1, imm5 is op=0x05 & reg0 & reg1 & imm5 {
	reg0 = reg1 s>> imm5;
}

:xori reg0, reg1, imm16 is op=0x06 & reg0 & reg1 & imm16 {
	reg0 = reg1 ^ imm16;
}

:lh reg0, reg1, simm16 is op=0x07 & reg0 & reg1 & simm16 {
	local address = reg1 + simm16;
	reg0 = sext(*[ram]:2 address);
}

:andi reg0, reg1, imm16 is op=0x08 & reg0 & reg1 & imm16 {
	reg0 = reg1 & imm16;
}

:xnori reg0, reg1, imm16 is op=0x09 & reg0 & reg1 & imm16 {
	reg0 = ~(reg1 ^ imm16);
}

:lw reg0, reg1, simm16 is op=0x0A & reg0 & reg1 & simm16 {
	local address = reg1 + simm16;
	reg0 = *[ram]:4 address;
}

:lhu reg0, reg1, simm16 is op=0x0B & reg0 & reg1 & simm16 {
	local address = reg1 + simm16;
	reg0 = zext(*[ram]:2 address);
}

:sb reg0, reg1 is op=0x0c & reg0 & reg1 {
	*[ram]:1 reg1 = reg0;
}

:addi reg0, reg1, simm16 is op=0x0D & reg0 & reg1 & simm16 {
	reg0 = reg1 + simm16;
}

:ori reg0, reg1, imm16 is op=0x0E & reg0 & reg1 & imm16 {
	reg0 = reg1 | imm16;
}

:sli reg0, reg1, imm5 is op=0x0F & reg0 & reg1 & imm5 {
	reg0 = reg1 << imm5;
}

:lbu reg0, reg1, simm16 is op=0x10 & reg0 & reg1 & simm16 {
	local address = reg1 + simm16;
	reg0 = zext(*[ram]:1 address);
}

:be reg0, reg1 Rel16 is op=0x11 & reg0 & reg1 & Rel16 {
	if (reg0 == reg1) goto Rel16;
}

:bg reg0, reg1 Rel16 is op=0x12 & reg0 & reg1 & Rel16 {
	if (reg0 s> reg1) goto Rel16;
}

:bge reg0, reg1 Rel16 is op=0x13 & reg0 & reg1 & Rel16 {
	if (reg0 s>= reg1) goto Rel16;
}

:bgeu reg0, reg1 Rel16 is op=0x14 & reg0 & reg1 & Rel16 {
	if (reg0 >= reg1) goto Rel16;
}

:bgu reg0, reg1 Rel16 is op=0x15 & reg0 & reg1 & Rel16 {
	if (reg0 > reg1) goto Rel16;
}

:sw reg0, reg1, simm16 is op=0x16 & reg0 & reg1 & simm16 {
	local address = reg0 + simm16;
	*[ram]:4 address = reg1;
}

:bne reg0, reg1 Rel16 is op=0x17 & reg0 & reg1 & Rel16 {
	if (reg0 != reg1) goto Rel16;
}

:andhi reg0, reg1, imm16 is op=0x18 & reg0 & reg1 & imm16 {
	reg0 = reg1 & (imm16 << 16);
}


:cmpei reg0, reg1, simm16 is op=0x19 & reg0 & reg1 & simm16 {
	reg0 = zext(reg1:4 == sext(simm16:2));
}

:cmpgi reg0, reg1, simm16 is op=0x1A & reg0 & reg1 & simm16 {
	reg0 = zext(reg1:4 s> sext(simm16:2));
}

:cmpgei reg0, reg1, simm16 is op=0x1B & reg0 & reg1 & simm16 {
	reg0 = zext(reg1:4 s>= sext(simm16:2));
}

:cmpgeui reg0, reg1, imm16 is op=0x1C & reg0 & reg1 & imm16 {
	reg0 = zext(reg1:4 >= zext(imm16:2));
}

:cmpgui reg0, reg1, imm16 is op=0x1D & reg0 & reg1 & imm16 {
	reg0 = zext(reg1:4 > zext(imm16:2));
}

:orhi reg0, reg1, imm16 is op=0x1E & reg0 & reg1 & imm16 {
	reg0 = reg1 | (imm16 << 16);
}


:cmpnei reg0, reg1, simm16 is op=0x1F & reg0 & reg1 & simm16 {
	reg0 = zext(reg1:4 != sext(simm16:2));
}

:sru reg0, reg1, reg2 is op=0x20 & reg0 & reg1 & reg2 {
	reg0 = reg1 >> reg2;
}

:nor reg0, reg1, reg2 is op=0x21 & reg0 & reg1 & reg2 {
	reg0 = ~(reg1 | reg2);
}

:mul reg0, reg1, reg2 is op=0x22 & reg0 & reg1 & reg2 {
	reg0 = (reg1 * reg2) & 0xFFFFFFFF;
}

:divu reg0, reg1, reg2 is op=0x23 & reg0 & reg1 & reg2 {
	reg0 = reg1 / reg2;
}

:rcsr is op=0x24 {

}

:sr reg0, reg1, reg2 is op=0x25 & reg0 & reg1 & reg2 {
	reg0 = reg1 s>> reg2;
}

:xor reg0, reg1, reg2 is op=0x26 & reg0 & reg1 & reg2 {
	reg0 = reg1 ^ reg2;
}

:div reg0, reg1, reg2 is op=0x27 & reg0 & reg1 & reg2 {
	reg0 = reg1 s/ reg2;
}

:and reg0, reg1, reg2 is op=0x28 & reg0 & reg1 & reg2 {
	reg0 = reg1 & reg2;
}

:xnor reg0, reg1, reg2 is op=0x29 & reg0 & reg1 & reg2 {
	reg0 = ~(reg1 ^ reg2);
}

# 0x2A is reserved

:raise is op=0x2B {

}

:sextb reg0, reg1 is op=0x2C & reg0 & reg1 {
	reg0 = (reg1 << 24) s>> 24;
}

:add reg0, reg1, reg2 is op=0x2D & reg0 & reg1 & reg2 {
	reg0 = reg1 + reg2;
}

:or reg0, reg1, reg2 is op=0x2E & reg0 & reg1 & reg2 {
	reg0 = reg1 | reg2;
}

:sl reg0, reg1, reg2 is op=0x2F & reg0 & reg1 & reg2 {
	reg0 = reg1 << reg2;
}

:b reg0 is op=0x30 & reg0 {
	goto [reg0];
}

:ret is op=0x30 & reg0=29  {
	return [ra];
}

:modu reg0, reg1, reg2 is op=0x31 & reg0 & reg1 & reg2 {
	reg0 = reg1 % reg2;
}

:sub reg0, reg1, reg2 is op=0x32 & reg0 & reg1 & reg2 {
	reg0 = reg1 - reg2;
}

# 0x33 is reserved

:wcsr is op=0x34 {

}

:mod reg0, reg1, reg2 is op=0x35 & reg0 & reg1 & reg2 {
	reg0 = reg1 s% reg2;
}

:call reg0 is op=0x36 & reg0 {
	call reg0;
}

:sexth reg0, reg1 is op=0x37 & reg0 & reg1 {
	reg0 = (reg1 << 16) s>> 16;
}

:bi Rel26 is op=0x38 & Rel26 {
	goto Rel26;
}

:cmpe reg0, reg1, reg2 is op=0x39 & reg0 & reg1 & reg2 {
	reg0 = zext(reg1 == reg2);
}

:cmpg reg0, reg1, reg2 is op=0x3A & reg0 & reg1 & reg2 {
	reg0 = zext(reg1 s> reg2);
}

:cmpge reg0, reg1, reg2 is op=0x3B & reg0 & reg1 & reg2 {
	reg0 = zext(reg1 s>= reg2);
}

:cmpgeu reg0, reg1, reg2 is op=0x3C & reg0 & reg1 & reg2 {
	reg0 = zext(reg1 >= reg2);
}

:cmpgu reg0, reg1, reg2 is op=0x3D & reg0 & reg1 & reg2 {
	reg0 = zext(reg1 > reg2);
}

:calli Rel26 is op=0x3E & Rel26 {
	call Rel26;
}

:cmpne reg0, reg1, reg2 is op=0x3F & reg0 & reg1 & reg2 {
	reg0 = zext(reg1 != reg2);
}
