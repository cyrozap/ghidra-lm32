# sleigh specification file for LM32

define endian=big;
define alignment=4;

define space ram type=ram_space size=4 size=4 wordsize=1 default;
define space register type=register_space size=4;

# General Purpose Registers
define register offset=0x1000 size=4 [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25
	gp fp sp ra ea ba
];

# Control and Status Registers
define register offset=0x2000 size=4 [
	PC IE IM IP ICC DCC CC CFG EBA CFG2
];

# Debug Control and Status Registers
define register offset=0x3000 size=4 [
	DC DEBA JTX JRX BP0 BP1 BP2 BP3 WP0 WP1 WP2 WP3
];

#
# Tokens
#

define token opfields(32)
	op = (26, 31)
	reg0 = (21, 25)
	reg1 = (16, 20)
	reg2 = (11, 15)
	imm16 = (0, 15)
	simm16 = (0, 15) signed
	imm26 = (0, 25)
	simm26 = (0, 25) signed
	imm5 = (0, 4)
	simm5 = (0, 4) signed
;

attach variables [ reg0 reg1 reg2 ] [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25
	gp fp sp ra ea ba
];

Rel26: reloc is simm26 [ reloc=inst_start+4*simm26; ] {
	export *:4 reloc;
}

Abs26: reloc is simm26 [ reloc=((inst_start+4) $and 0xfffffffff0000000) | 4*simm26; ] {
	export *:4 reloc;
}

#
# Instructions
#

:srui reg0, reg1, imm5 is op=0x00 & reg0 & reg1 & imm5 {
	reg0 = reg1 >> imm5;
}

:nori reg0, reg1, imm16 is op=0x01 & reg0 & reg1 & imm16 {
	reg0 = ~(reg1 | imm16);
}

:muli reg0, reg1, imm16 is op=0x02 & reg0 & reg1 & imm16 {
	reg0 = reg1 * imm16;
}

# :sh reg0, reg1, imm16 is op=0x03 {
#:sh reg0, reg1, imm16 is op=0x03 {
#	# address = gpr[rX] + sign_extend(imm16)
#	# memory[address] = (gpr[rY] >> 8) & 0xff
#	# memory[address+1] = gpr[rY] & 0xff
#	address = reg0 + sext(imm16)
#	*[ram]:4 reg0 + sext(imm16) = reg1
#}

:sh reg0, reg1 is op=0x03 & reg0 & reg1 {
	*[ram]:2 reg1 = reg0;
}

#:sw rn, "("^rm^")" is op0003=0xA & op1215=0 & rn & rm {
#	*[ram]:4 rm = rn;
#}

:lb is op=0x04 {

}

:sri reg0, reg1, imm16 is op=0x05 & reg0 & reg1 ; imm16 {
	reg0 = reg1 >> imm16;
}

:xori is op=0x06 {

}

:lh is op=0x07 {

}

:andi is op=0x08 {

}

:xnori is op=0x09 {

}

:lw is op=0x0A {

}

:lhu is op=0x0B {

}

:sb is op=0x0C {

}

:addi reg0, reg1, simm16 is op=0x0D & reg0 & reg1 & simm16 {
	reg0 = reg1 + simm16;
}

:ori reg0, reg1, imm16 is op=0x0E & reg0 & reg1 & imm16 {
	reg0 = reg1 | imm16;
}

:sli is op=0x0F {

}

:lbu is op=0x10 {

}

:be is op=0x11 {

}

:bg is op=0x12 {

}

:bge is op=0x13 {

}

:bgeu is op=0x14 {

}

:bgu is op=0x15 {

}

:sw reg0, reg1, simm16 is op=0x16 & reg0 & reg1 & simm16 {
	local address = reg0 + simm16;
	*[ram]:4 address = reg1;
}

:bne is op=0x17 {

}

:andhi is op=0x18 {

}

:cmpei is op=0x19 {

}

:cmpgi is op=0x1A {

}

:cmpgei is op=0x1B {

}

:cmpgeui is op=0x1C {

}

:cmpgui is op=0x1D {

}

:orhi reg0, reg1, imm16 is op=0x1E & reg0 & reg1 & imm16 {
	reg0 = reg1 | (imm16 << 16);
}

:cmpnei is op=0x1F {

}

:sru is op=0x20 {

}

:nor is op=0x21 {

}

:mul is op=0x22 {

}

:divu is op=0x23 {

}

:rcsr is op=0x24 {

}

:sr is op=0x25 {

}

:xor is op=0x26 {

}

:div is op=0x27 {

}

:and is op=0x28 {

}

:xnor is op=0x29 {

}

# 0x2A is reserved

:raise is op=0x2B {

}

:sextb is op=0x2C {

}

:add reg0, reg1, reg2 is op=0x2D & reg0 & reg1 & reg2 {
	reg0 = reg1 + reg2;
}

:or reg0, reg1, reg2 is op=0x2E & reg0 & reg1 & reg2 {
	reg0 = reg1 | reg2;
}

:sl is op=0x2F {

}

:b reg0 is op=0x30 & reg0 {
	goto reg0;
}

:modu is op=0x31 {

}

:sub reg0, reg1, reg2 is op=0x32 & reg0 & reg1 & reg2 {
	reg0 = reg1 - reg2;
}

# 0x33 is reserved

:wcsr is op=0x34 {

}

:mod is op=0x35 {

}

:call is op=0x36 {

}

:sexth is op=0x37 {

}

:bi Rel26 is op=0x38 & Rel26 {
	goto Rel26;
}

:cmpe is op=0x39 {

}

:cmpg is op=0x3A {

}

:cmpge is op=0x3B {

}

:cmpgeu is op=0x3C {

}

:cmpgu is op=0x3D {

}

:calli is op=0x3E {

}

:cmpne is op=0x3F {

}
