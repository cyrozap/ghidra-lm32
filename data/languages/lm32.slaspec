# sleigh specification file for LM32

define endian=big;
define alignment=4;

define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

# General Purpose Registers
define register offset=0x1000 size=4 [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25
	gp fp sp ra ea ba
];

# Control and Status Registers
define register offset=0x2000 size=4 [
	PC IE IM IP ICC DCC CC CFG EBA CFG2
];

# Debug Control and Status Registers
define register offset=0x3000 size=4 [
	DC DEBA JTX JRX BP0 BP1 BP2 BP3 WP0 WP1 WP2 WP3
];

define register offset=0x4000 size=4 contextreg;
define context contextreg
	LRset = (1,1) noflow  # 1 if the instruction before was a mov lr,pc
;

#
# Tokens
#

define token opfields(32)
	b31 = (31, 31)
	op = (26, 31)
	op5 = (26, 30)
	reg0 = (21, 25)
	reg1 = (16, 20)
	reg2 = (11, 15)
	imm16 = (0, 15)
	simm16 = (0, 15) signed
	imm26 = (0, 25)
	simm26 = (0, 25) signed
	imm5 = (0, 4)
	simm5 = (0, 4) signed
	z11 = (0, 10)
	z16 = (0, 16)
;

attach variables [ reg0 reg1 reg2 ] [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25
	gp fp sp ra ea ba
];

Rel16: reloc is simm16 [ reloc=inst_start+4*simm16; ] {
	export *:4 reloc;
}

Rel26: reloc is simm26 [ reloc=inst_start+4*simm26; ] {
	export *:4 reloc;
}

inst_fmt_ri: is_inst_fmt_ri is b31 [ is_inst_fmt_ri=b31; ] { export *:1 is_inst_fmt_ri; }
# inst_fmt_ri: is_inst_fmt_ri is b31=1 [ is_inst_fmt_ri=0; ] { export *:1 is_inst_fmt_ri; }
# inst_fmt_ri: is_inst_fmt_ri is b31=0 [ is_inst_fmt_ri=1; ] { export *:1 is_inst_fmt_ri; }
# inst_fmt_ri: "ri1" is b31=0 { export 1:1; }
# inst_fmt_i: { export 0:1; }
# inst_fmt_i: is b31=1 & (op5=0x18 | op5=0x1e) { export 1:1; }
# inst_fmt_cr: { export 0:1; }
# inst_fmt_cr: is b31=1 & (op5=0x04 | op5=0x14) { export 1:1; }
# inst_fmt_rr: { export zext(inst_fmt_ri | inst_fmt_i | inst_fmt_cr) == 0):1; }



gpr0: reg0 is reg0 { export reg0; }
gpr0: "0" is reg0=0 { export 0:4; } # Special case

gpr1: reg1 is reg1 { export reg1; }
gpr1: "0" is reg1=0 { export 0:4; } # Special case

gpr2: reg2 is reg2 { export reg2; }
gpr2: "0" is reg2=0 { export 0:4; } # Special case

# inst_fmt_ri: "ri0" is inst_fmt_ri { export 0:1; }
# inst_fmt_ri: "ri1" is b31=0 { export 1:1; }
# inst_fmt_i: { export 0:1; }
# inst_fmt_i: is b31=1 & (op5=0x18 | op5=0x1e) { export 1:1; }
# inst_fmt_cr: { export 0:1; }
# inst_fmt_cr: is b31=1 & (op5=0x04 | op5=0x14) { export 1:1; }
# inst_fmt_rr: { export zext(inst_fmt_ri | inst_fmt_i | inst_fmt_cr) == 0):1; }

# rX: reg2 is reg2 & is_inst_fmt_rr=1 { export reg2; }
# rY: reg0 is reg0 & is_inst_fmt_rr=1 { export reg0; }
# rZ: reg1 is reg1 & is_inst_fmt_rr=1 { export reg1; }

rX: reg1 is reg1 & inst_fmt_ri { export reg1; }
rY: reg0 is reg0 & inst_fmt_ri { export reg0; }

#
# Instructions
#

:srui gpr0, gpr1, imm5 is op=0x00 & gpr0 & gpr1 & imm5 {
	r0=0;
	gpr0 = gpr1 >> imm5;
	r0=0;
}

:nori gpr0, gpr1, imm16 is op=0x01 & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = ~(gpr1 | imm16);
	r0=0;
}

:muli gpr0, gpr1, simm16 is op=0x02 & gpr0 & gpr1 & simm16 {
	r0=0;
	gpr0 = ((gpr1 * simm16) & 0xFFFFFFFF);
	r0=0;
}

:sh gpr0, gpr1, simm16 is op=0x03 & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr1 + simm16;
	*[ram]:2 address = gpr0;
	r0=0;
}

:lb gpr0, gpr1, simm16 is op=0x04 & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr1 + simm16;
	gpr0 = sext(*[ram]:1 address);
	r0=0;
}

:sri gpr0, gpr1, imm5 is op=0x05 & gpr0 & gpr1 & imm5 {
	r0=0;
	gpr0 = gpr1 s>> imm5;
	r0=0;
}

:xori gpr0, gpr1, imm16 is op=0x06 & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = gpr1 ^ imm16;
	r0=0;
}

:lh gpr0, gpr1, simm16 is op=0x07 & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr1 + simm16;
	gpr0 = sext(*[ram]:2 address);
	r0=0;
}

:andi gpr0, gpr1, imm16 is op=0x08 & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = gpr1 & imm16;
	r0=0;
}

:xnori gpr0, gpr1, imm16 is op=0x09 & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = ~(gpr1 ^ imm16);
	r0=0;
}

:lw gpr0, gpr1, simm16 is op=0x0A & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr1 + simm16;
	gpr0 = *[ram]:4 address;
	r0=0;
}

:lhu gpr0, gpr1, simm16 is op=0x0B & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr1 + simm16;
	gpr0 = zext(*[ram]:2 address);
	r0=0;
}

:sb gpr0, gpr1 is op=0x0c & gpr0 & gpr1 {
	r0=0;
	*[ram]:1 gpr1 = gpr0;
	r0=0;
}

# :addi gpr0, gpr1, simm16 is op=0x0D & gpr0 & gpr1 & simm16 {
# 	r0=0;
# 	gpr0 = gpr1 + simm16;
# 	r0=0;
# }

:addi gpr0, gpr1, simm16 is op=0x0D & gpr0 & gpr1 & simm16 {
	r0=0;
	gpr0 = gpr1 + simm16;
	r0=0;
}

# :addi rX, rY, simm16 is op=0x0D & rX & rY & simm16 {
# 	r0=0;
# 	rX = rY + simm16;
# 	r0=0;
# }


:ori gpr0, gpr1, imm16 is op=0x0E & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = gpr1 | imm16;
	r0=0;
}

:sli gpr0, gpr1, imm5 is op=0x0F & gpr0 & gpr1 & imm5 {
	r0=0;
	gpr0 = gpr1 << imm5;
	r0=0;
}

:lbu gpr0, gpr1, simm16 is op=0x10 & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr1 + simm16;
	gpr0 = zext(*[ram]:1 address);
	r0=0;
}

:be gpr0, gpr1 Rel16 is op=0x11 & gpr0 & gpr1 & Rel16 {
	r0=0;
	if (gpr0 == gpr1) goto Rel16;
	r0=0;
}

:bg gpr0, gpr1 Rel16 is op=0x12 & gpr0 & gpr1 & Rel16 {
	r0=0;
	if (gpr0 s> gpr1) goto Rel16;
	r0=0;
}

:bge gpr0, gpr1 Rel16 is op=0x13 & gpr0 & gpr1 & Rel16 {
	r0=0;
	if (gpr0 s>= gpr1) goto Rel16;
	r0=0;
}

:bgeu gpr0, gpr1 Rel16 is op=0x14 & gpr0 & gpr1 & Rel16 {
	r0=0;
	if (gpr0 >= gpr1) goto Rel16;
	r0=0;
}

:bgu gpr0, gpr1 Rel16 is op=0x15 & gpr0 & gpr1 & Rel16 {
	r0=0;
	if (gpr0 > gpr1) goto Rel16;
	r0=0;
}

:sw gpr0, gpr1, simm16 is op=0x16 & gpr0 & gpr1 & simm16 {
	r0=0;
	local address = gpr0 + simm16;
	*[ram]:4 address = gpr1;
	r0=0;
}

:bne gpr0, gpr1 Rel16 is op=0x17 & gpr0 & gpr1 & Rel16 {
	r0=0;
	if (gpr0 != gpr1) goto Rel16;
	r0=0;
}

:andhi gpr0, gpr1, imm16 is op=0x18 & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = gpr1 & (imm16 << 16);
	r0=0;
}


:cmpei gpr0, gpr1, simm16 is op=0x19 & gpr0 & gpr1 & simm16 {
	r0=0;
	gpr0 = zext(gpr1:4 == sext(simm16:2));
	r0=0;
}

:cmpgi gpr0, gpr1, simm16 is op=0x1A & gpr0 & gpr1 & simm16 {
	r0=0;
	gpr0 = zext(gpr1:4 s> sext(simm16:2));
	r0=0;
}

:cmpgei gpr0, gpr1, simm16 is op=0x1B & gpr0 & gpr1 & simm16 {
	r0=0;
	gpr0 = zext(gpr1:4 s>= sext(simm16:2));
	r0=0;
}

:cmpgeui gpr0, gpr1, imm16 is op=0x1C & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = zext(gpr1:4 >= zext(imm16:2));
	r0=0;
}

:cmpgui gpr0, gpr1, imm16 is op=0x1D & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = zext(gpr1:4 > zext(imm16:2));
	r0=0;
}

:orhi gpr0, gpr1, imm16 is op=0x1E & gpr0 & gpr1 & imm16 {
	r0=0;
	gpr0 = gpr1 | (imm16 << 16);
	r0=0;
}


:cmpnei gpr0, gpr1, simm16 is op=0x1F & gpr0 & gpr1 & simm16 {
	r0=0;
	gpr0 = zext(gpr1:4 != sext(simm16:2));
	r0=0;
}

:sru gpr0, gpr1, gpr2 is op=0x20 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 >> gpr2;
	r0=0;
}

:nor gpr0, gpr1, gpr2 is op=0x21 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = ~(gpr1 | gpr2);
	r0=0;
}

:mul gpr0, gpr1, gpr2 is op=0x22 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = (gpr1 * gpr2) & 0xFFFFFFFF;
	r0=0;
}

:divu gpr0, gpr1, gpr2 is op=0x23 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 / gpr2;
	r0=0;
}

:rcsr is op=0x24 {
	r0=0;

	r0=0;
}

:sr gpr0, gpr1, gpr2 is op=0x25 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 s>> gpr2;
	r0=0;
}

:xor gpr0, gpr1, gpr2 is op=0x26 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 ^ gpr2;
	r0=0;
}

:div gpr0, gpr1, gpr2 is op=0x27 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 s/ gpr2;
	r0=0;
}

:and gpr0, gpr1, gpr2 is op=0x28 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 & gpr2;
	r0=0;
}

:xnor gpr0, gpr1, gpr2 is op=0x29 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = ~(gpr1 ^ gpr2);
	r0=0;
}

# 0x2A is reserved

:raise is op=0x2B {
	r0=0;

	r0=0;
}

:sextb gpr0, gpr1 is op=0x2C & gpr0 & gpr1 {
	r0=0;
	gpr0 = (gpr1 << 24) s>> 24;
	r0=0;
}

# :add gpr0, gpr1, gpr2 is op=0x2D & gpr0 & gpr1 & gpr2 {
# 	r0=0;
# 	gpr0 = gpr1 + gpr2;
# 	r0=0;
# }

:add gpr0, gpr1, gpr2 is op=0x2D & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 + gpr2;
	r0=0;
}

# :add rX, rY, rZ is op=0x2D & rX & rY & rZ {
# 	r0=0;
# 	rX = rY + rZ;
# 	r0=0;
# }

:or gpr0, gpr1, gpr2 is op=0x2E & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 | gpr2;
	r0=0;
}

:sl gpr0, gpr1, gpr2 is op=0x2F & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 << gpr2;
	r0=0;
}

:b gpr0 is op=0x30 & gpr0 {
	r0=0;
	goto [gpr0];
}

:ret is op=0x30 & reg0=29 {
	r0=0;
	goto [ra];
}

:modu gpr0, gpr1, gpr2 is op=0x31 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 % gpr2;
	r0=0;
}

:sub gpr0, gpr1, gpr2 is op=0x32 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 - gpr2;
	r0=0;
}

# 0x33 is reserved

:wcsr is op=0x34 {
	r0=0;

	r0=0;
}

:mod gpr0, gpr1, gpr2 is op=0x35 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = gpr1 s% gpr2;
	r0=0;
}

:call gpr0 is op=0x36 & gpr0 {
	r0=0;
	ra = PC + 4;
	call [gpr0];
}

:sexth gpr0, gpr1 is op=0x37 & gpr0 & gpr1 {
	r0=0;
	gpr0 = (gpr1 << 16) s>> 16;
	r0=0;
}

:bi Rel26 is op=0x38 & Rel26 {
	r0=0;
	goto Rel26;
}

:cmpe gpr0, gpr1, gpr2 is op=0x39 & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = zext(gpr1 == gpr2);
	r0=0;
}

:cmpg gpr0, gpr1, gpr2 is op=0x3A & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = zext(gpr1 s> gpr2);
	r0=0;
}

:cmpge gpr0, gpr1, gpr2 is op=0x3B & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = zext(gpr1 s>= gpr2);
	r0=0;
}

:cmpgeu gpr0, gpr1, gpr2 is op=0x3C & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = zext(gpr1 >= gpr2);
	r0=0;
}

:cmpgu gpr0, gpr1, gpr2 is op=0x3D & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = zext(gpr1 > gpr2);
	r0=0;
}

:calli Rel26 is op=0x3E & Rel26 {
	r0=0;
	ra = PC + 4;
	call Rel26;
}

:cmpne gpr0, gpr1, gpr2 is op=0x3F & gpr0 & gpr1 & gpr2 {
	r0=0;
	gpr0 = zext(gpr1 != gpr2);
	r0=0;
}
